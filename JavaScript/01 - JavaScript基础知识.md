---
cover: 'https://source.unsplash.com/user/erondu/1440x960'
coverWidth: 1200
coverHeight: 750
title: JavaScript基础知识综合
categories: JavaScript
tags: JavaScript
top:
permalink:
---

[TOC]

#### 01 / JS数据类型(6+1)

**基本数据类型:**

```
- null
- undefined
- number
- string
- boolean
- symbol:代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。
```

**引用数据类型:**

引用数据类型指的是object类型,其他如Array,Date等数据类型都可以理解为Object的子类

```
object =  [
   Array,
   Date,
   Math,
   ...
]
```

**基本数据类型和引用数据类型区别:**

- 基本数据类型在内存中占固定大小的空间,因此被保存在栈中
- 引用类型值是对象，保存在 **堆内存** 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。

#### 02 / 什么是堆/栈?

堆栈概念存在于**数据结构**和**操作系统**内存中

- 在数据结构中:

  - 栈中的数据存取方式为先进后出
  - 堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定

- 操作系统中 ,内存被分为栈区和堆区:

  - 栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等
- 堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收机制回收

#### 03 / 什么是JavaSctipt垃圾回收机制?

- **为什么要垃圾回收?**

  ```html
  随着前端业务需求的不断增多，相比以前，我们会占用更多的内存。
  但是内存并不是无限的，而对于那些我们不再需要的变量、对象该怎么处理呢？
  这里就是垃圾回收机制的作用
  ```

- **垃圾回收机制的特点:**

  垃圾回收机制，会定期对那些我们不再使用的变量、对象所占用的内存进行释放

  ```
  原理:
  	+ 找出那些不再使用的变量，然后释放其占用的内存。
  	+ 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。
  ```

- **垃圾回收的方式有哪些?**

  - 标记清除

    - 当变量进入环境时,就将其标记为"进入环境",此时"进入环境"的变量是不可以被回收的"

    - 当变量离开环境时,就将其标记为"离开环境",此时"离开环境"的变量可以被回收
  
      ```
    function func () {
            const a = 1
          const b = 2
            // 函数执行时，a b 分别被标记 进入环境
      }
      
      func() // 函数执行结束，a b 被标记 离开环境，被回收
      ```
  
  - 引用计数
  
    - 统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收
  
      ```
      function func1 () {
            const c = {} // 引用类型变量 c的引用计数为 0
            let d = c // c 被 d 引用 c的引用计数为 1
            let e = c // c 被 e 引用 c的引用计数为 2
            d = {} // d 不再引用c c的引用计数减为 1
            e = null // e 不再引用 c c的引用计数减为 0 将被回收
      }
      ```
  
    - 但是引用计数的方式，有一个相对明显的缺点——**循环引用**
  
      ```
      function func5 () {
            let f = {}
            let g = {}
            f.prop = g
            g.prop = f
            // 由于 f 和 g 互相引用，计数永远不可能为 0
      }
      ```
  
    - 像上面这种情况就需要**手动将变量的内存释放**
  
      ```
      f.prop = null
      g.prop = null
      ```
  
      参考:
      	 [<<javascript 垃圾回收机制>>](https://juejin.im/post/6844903652331618312)	
      	 [<<JavaScript 垃圾回收机制>>](https://juejin.im/post/6844903858972409869#heading-3)

#### 04 / 什么是循环引用 ?

当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用(最简单的例子)

```
  function circularReference() {
      let obj1 = { };
      let obj2 = { };
      obj1.a = obj2;
      obj2.b = obj1;
  }
```

#### 05 / 内存泄露

- 什么是内存泄露?

  ```
  程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。
  对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。
  否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。
  不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。
  ```

- 常见的内存泄露有哪些?

  - 全局变量(在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量。)
    ```js
    function foo（arg）{ 
        bar =“some text”; // bar将泄漏到全局.
    }
    ```
  -  被遗忘的定时器和回调函数
  
  - DOM引用
  
  - 闭包
  


#### 06 /  JavaScript可执行上下文

<a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank"><<JavaScript可执行上下文>></a>

#### 07 /  JavaScript在浏览器中执行顺序

<a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank"><<JavaScript在浏览器中执行顺序>></a>

#### 08 /  从输入url到页面加载过程

<a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank"><<从输入url到页面加载过程>></a>

#### 09 / 内部属性[[class]]是什么

所有typeof返回Object的对象都有一个内部属性.可以通过以下代码查看

```
Object.prototype.toString.call(Array)  //"[object Function]"
```

#### 10 / Js内置对象都有哪些

```
js内置对象主要是只在程序执行前存在全局作用域里面的由js定义的一些全局属性,函数和用来实例化其他对象的构造函数对象.

一般我们经常用到的全局函数变量值 NaN , undefined ,

全局函数: parseInt() , paeseFloat()

用来实例化的全局构造函数: Date , Object 等
```

#### 11 / 原型原型链

[<<JavaScript原型原型链>>]()

#### 12 / 闭包

```
闭包是指内部函数可以访问其所在的外部函数中声明的参数和变量;

创建闭包最常用的方法是在一个函数内创建另外一个函数,创建的函数可以访问父级函数的局部变量;

闭包主要有两个用途:

1/ 使我们可以在函数外部访问到函数内部的变量,通过这个方法,我们可以在函数外部调用闭包函数,在函数外部访问到函数内部变量

2/ 使已经运行过的函数上下文的变量对象继续保存在内存中,不被垃圾回收机制释放内存,但是操作不当可能会造成内存泄露
```

#### 13 / 继承

```
继承实现方式:
- 原型链继承
- 构造函数继承
- 组合继承(原型链+构造函数继承)
- 原型式继承
- 寄生式继承
- 寄生组合式继承
```

[<<JavaScript深入之继承的多种方式和优缺点>>](https://github.com/mqyqingfeng/Blog/issues/16)

#### 14 / 什么是 pure function

如果一个函数没有任何副作用（side-effects)，不会影响任何外部状态，对于任何一个相同的输入（参数），无论何时调用这个函数总是返回同样的结果，这个函数就是一个 pure function。

#### 15 / 重绘回流

- **回流:**DOM节点中的各个元素都是以盒模型的形式存在,需要浏览器来计算其位置和大小等,该过程叫做回流
- **重绘:**当盒模型的位置,大小以及其他属性,如颜色,字体等确定下来之后,浏览器就开始绘制内容,该过程叫做重绘

#### 16 / http缓存

```
http缓存按我自己的理解:
我更愿意叫做浏览器缓存,缓存主要发生在浏览器端,而http起到的作用是告诉浏览器是否使用缓存资源,是否进行缓存...

01/ 为什么要缓存呢?
用于性能提升,减少延迟,提高网页加载速度;同时,由于缓存文件可以重复利用,还可以减少带宽,降低网络负荷

02/ 浏览器缓存方式:
浏览器缓存分为两种
-	强制缓存
- 协商缓存

03/ 浏览器怎么才能缓存?
http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。
可以约定
```

参考:

- [<<前端优化：浏览器缓存技术介绍>>](https://juejin.im/post/6844903672556552205#heading-2)
- [<<http面试必会的：强制缓存和协商缓存>>](https://juejin.im/post/6844903838768431118#heading-0)

#### 17 / SSR/BSR区别

- SSR:服务端渲染

  对营销推广的要求比较高的产品,比如官网等

  ```
  - M+V发生在服务端,服务器压力较大
  - 页面访问和显示速度更快(DOM比较少)
  - 有利于SEO搜索引擎优化
  - 前后端不分离,后端开发压力大
  - 功能不能过于复杂,多用于功能交互都比较简单的产品
  ```

- BSR:客户端渲染

  对营销推广要求没有那么搞的产品,例如后台管理系统

  ```
  - M+v过程发生在浏览器,浏览器压力较大
  - 页面访问和加载速度没有服务端渲染快
  - 不利于SEO优化
  - 前后端分离,便于代码调试和维护
  - 可以做更加复杂的产品
  ```

#### 18 / SEO优化





